/* global afterEach, beforeEach, describe, expect, falafel, it, mongo */
describe('The mutateSource module', function () {
  var ms = mongo.mutateSource;

  /**
   * Returns an AST generated by falafel and all nodes of the specified type.
   * If the type is not specified, an empty array is returned.
   *
   * falafel adds attributes such as node.parent which many of the methods
   * under testing rely upon so esprima cannot be used be itself. However,
   * falafel does not return its AST directly, so this method takes the root
   * from the last node visited in the reverse traversal (leaf to root).
   */
  function getFalafelAST(source, nodeType) {
    var root, nodes = [];
    falafel(source, function (node) {
      root = node;
      if (nodeType && node.type === nodeType) { nodes.push(node); }
    });
    return {ast: root, nodes: nodes};
  }

  it('hides global func declarations within a Shell variable', function () {
    var source = 'function a(b, c) { function d(e) { return 4; } }';
    var shellID = 0;
    var expected = 'mongo.shells[' + shellID + '].vars.a = function (b, c) ' +
        '{ function d(e) { return 4; } }';
    expected = expected.replace(/\s+/g, '');

    var out = getFalafelAST(source, 'FunctionDeclaration');
    out.nodes.forEach(function (node) {
      ms._mutateFunctionDeclaration(node, shellID);
    });
    var actual = out.ast.source().replace(/\s+/g, '');
    expect(actual).toEqual(expected);
  });

  it('hides global identifiers within a Shell variable', function () {
    var source = 'var a; b = 0; function c(d) { e = f; var g; } h.h = 2; ' +
        'i = {j: 3}; mongo.keyword = 4; mongo.keyword.evaluate();';
    var shellID = 0;
    var shell = 'mongo.shells[' + shellID + '].vars.';
    var expected = 'var ' + shell + 'a; ' + shell + 'b = 0; function c(d) { ' +
        shell + 'e = ' + shell + 'f; var g; } ' + shell + 'h.h = 2; ' + shell +
        'i ' + '= {j: 3}; ' + shell + 'mongo.keyword = 4; ' +
        'mongo.keyword.evaluate();';
    expected = expected.replace(/\s+/g, '');

    var out = getFalafelAST(source, 'Identifier');
    out.nodes.forEach(function (node) {
      ms._mutateIdentifier(node, shellID);
    });
    var actual = out.ast.source().replace(/\s+/g, '');
    expect(actual).toEqual(expected);
  });

  it('replaces db.collection member expressions with a Query', function () {
    var source = [
      'a.collection;',
      'db.col;',
      'db[iu].find(\'joeun nal\');'
    ].join(' ');
    var shellID = 0;
    var query = 'new mongo.Query(mongo.shells[' + shellID + '], ';
    var expected = [
      'a.collection;',
      query + '"col");',
      query + 'iu).find(\'joeun nal\');'
    ].join(' ').replace(/\s+/g, '');

    var out = getFalafelAST(source, 'MemberExpression');
    out.nodes.forEach(function (node) {
      ms._mutateMemberExpression(node, shellID);
    });
    var actual = out.ast.source().replace(/\s+/g, '');
    expect(actual).toEqual(expected);
  });

  it('mutates variable declarations', function () {
    var source = [
      'a = 0;',
      'var b;',
      'var c = 1;',
      'function d(e) { var f; g = 4; }'
    ].join(' ');
    var expected = [
      'a = 0;',
      '(function () { }());',
      '(function () { c = 1; }());',
      'function d(e) { var f; g = 4; }'
    ].join(' ').replace(/\s+/g, '');
    var out = getFalafelAST(source, 'VariableDeclaration');
    out.nodes.forEach(function (node) {
      ms._mutateVariableDeclaration(node);
    });
    var actual = out.ast.source().replace(/\s+/g, '');
    expect(actual).toEqual(expected);
  });

  it('gets the local variable identifiers of the current node', function () {
    var source =
        'var global;' +
        'global2 = 2;' +
        'function one(a) {' +
          'global3 = 3;' +
          'var b, c = 3;' +
          'var d = function (x) {' +
            'global4 = 4;' +
            'var y, z = 4;' +
          '}' +
        '}';
    var ast = getFalafelAST(source).ast;
    var scope = {
      top: ast.body[0],
      mid: ast.body[2].body.body[0],
      bottom: ast.body[2].body.body[2].declarations[0].init.body.body[0]
    };
    var expected = {
      top: {},
      mid: {one: true, a: true, b: true, c: true, d: true},
      bottom: {one: true, a: true, b: true, c: true, d: true, x: true, y: true,
        z: true}
    };
    for (var key in expected) {
      if (expected.hasOwnProperty(key)) {
        expect(ms._getLocalVariableIdentifiers(scope[key])).toEqual(
            expected[key]);
      }
    }
  });

  describe('working with identifiers', function () {
    var funcNode;

    beforeEach(function () {
      var source = 'function a(aa, bb, cc) { var b, c; var d; }' +
          'var e = function f(dd, ee, ff) { var g; };';
      var ast = getFalafelAST(source).ast;
      funcNode = {
        a: ast.body[0],
        f: ast.body[1].declarations[0].init
      };
    });

    afterEach(function () {
      funcNode = null;
    });

    it('extracts identifiers of parameters to a function', function () {
      var expected = {
        a: {aa: true, bb: true, cc: true},
        f: {dd: true, ee: true, ff: true}
      };
      for (var key in expected) {
        if (expected.hasOwnProperty(key)) {
          var paramsNode = funcNode[key].params;
          expect(ms._extractParamsIdentifiers(paramsNode)).toEqual(
              expected[key]);
        }
      }
    });

    it('extracts identifiers in the body of a function', function () {
      var expected = {
        a: {b: true, c: true, d: true},
        f: {g: true}
      };
      for (var key in expected) {
        if (expected.hasOwnProperty(key)) {
          var bodyNode = funcNode[key].body;
          expect(ms._extractBodyIdentifiers(bodyNode)).toEqual(expected[key]);
        }
      }
    });
  });

  describe('working with containing functions', function () {
    var varDeclNode, topFnNode, bottomFnNode, returnNode;

    beforeEach(function () {
      var source = [
        'var iu = \'<3\';',
        'function four() { var n = function () { return 4; }; return n(); }'
      ].join(' ');
      var ast = getFalafelAST(source).ast;
      varDeclNode = ast.body[0];
      topFnNode = ast.body[1];
      bottomFnNode = topFnNode.body.body[0].declarations[0].init;
      returnNode = bottomFnNode.body.body[0];
    });

    afterEach(function () {
      varDeclNode = topFnNode = bottomFnNode = returnNode = null;
    });

    it('gets the containing function node of the current one', function () {
      expect(ms._getContainingFunctionNode(varDeclNode)).toBeNull();

      expect(ms._getContainingFunctionNode(returnNode)).toEqual(bottomFnNode);
      expect(ms._getContainingFunctionNode(bottomFnNode)).toEqual(topFnNode);
      expect(ms._getContainingFunctionNode(topFnNode)).toBeNull();
    });

    it('says whether a node is contained within a function node', function () {
      expect(ms._nodeIsInsideFunction(varDeclNode)).toBe(false);
      expect(ms._nodeIsInsideFunction(returnNode)).toBe(true);
    });
  });

  it('swaps user input calls ', function () {
    // XXX: If the output of this method were to be tested thoroughly without
    // stubbing methods, we would be doing a lot of repetitive work as this
    // method is essentially a wrapper. However, we cannot stub these methods
    // directly since they are called from within the module closure and
    // moving to an external reference would be unsafe and thus in bad taste.
    // As such, a basic test exists here but it is not thorough - that is left
    // for the node-specific methods it calls.
    var userInput = 'a = 4;';
    var shellID = 0;
    var expected = 'mongo.shells[' + shellID + '].vars.a = 4;';
    expected = expected.replace(/\s+/g, '');
    var actual = mongo.mutateSource.swapMongoCalls(userInput, shellID).replace(
        /\s+/g, '');
    expect(actual).toEqual(expected);
  });

  it('replaces keywords with valid JavaScript calls', function () {
    var shellID = 0;
    function getResult() {
      var args = Array.prototype.slice.call(arguments).map(function (arg) {
        return '\'' + arg + '\'';
      }).join(', ');
      args = [shellID].concat(args);
      return 'mongo.keyword.evaluate(' + args + ')';
    }
    var source = [
      'help', 'it', 'show', 'use',
      'help arg1',
      'help arg1 arg2',
      'help arg1 arg2 unusedArg',
      'not a keyword'
    ].join('; ');
    var expected = [
      getResult('help'), getResult('it'), getResult('show'), getResult('use'),
      getResult('help', 'arg1'),
      getResult('help', 'arg1', 'arg2'),
      getResult('help', 'arg1', 'arg2', 'unusedArg'),
      'not a keyword'
    ].join('; ').replace(/\s+/g, '');
    var actual = ms.swapKeywords(source, shellID).replace(/\s+/g, '');
    expect(actual).toEqual(expected);
  });

  it('converts the given tokens into a mongo.keyword call', function () {
    var shellID = 0;
    var tokens = ['one', 'two', 'three'];
    var expected = 'mongo.keyword.evaluate(' + shellID + ', \'one\', ' +
        '\'two\', \'three\')';
    var actual = ms._convertTokensToKeywordCall(shellID, tokens);
    expect(actual).toEqual(expected);
  });
});
